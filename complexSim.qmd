---
title: "Nonpara clustering"
date: 2023-10-19
format: 
  pdf:
    toc: true
execute: 
  echo: true
  warning: false
  message: false
  error: false
---



# Simulation
```{python setup}
#| include: false
#| output: false
#| message: false

from ctypes import CDLL 
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.api import OLS
import os

try : 
  os.chdir("../../Stat_gen/tools/MASH")
  from Simulate.simulation_helpers.Sim_generator import pheno_simulator
  from Simulate.summarizers.genotype_viz import plotClusters
  # from Simulate.summarizers.genotype_viz import plotClusters
  os.chdir("../../../Integrative/prsPPMx/")
except NameError :
  print("Already loaded appropriate modules")
```
- $\#SNPs = $ `python print(nSNPs)` $< 2000$ [is typical](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6931355/)
- $\#Subjects = $ `python print(nsubjects)`

```{python}
#| message: false

nSNPs = 1000
nsubjects = 500
nclusts = 1
nphenos = 2
shared = 0.5
prop_causal = [0.25, 0.25]
theta_alleles = [0.95, 0.25]
h2Hom =0.5
confound = 0.1
confounder_eff= 3
subgroup_eff = 5
# Add this for transfer learning 
h2Het = [0.4, 0.4]

rng = np.random.default_rng()
nclusts = 2 

sim = pheno_simulator(nsubjects = nsubjects, nSNPs = nSNPs)
sim.sim_sites()
sim.sim_pops(nclusts = nclusts, theta_alleles = theta_alleles, shared = shared)
sim.sim_genos()
sim.sim_pheno(h2Hom =h2Hom, h2Het = h2Het, nphenos = nphenos, prop_causal = prop_causal, alpha =-1)
# Subtract the mean from every column starting with Y and store them in the dataframe
sim.df.iloc[:,30:(30+nphenos)] = sim.df.filter(regex='^Y') - sim.df.filter(regex= "^Y").mean()

# Add a mean for subgroups
sim.df["subgroup"] = np.repeat([0, 1], 250)
sim.df.Y1 = sim.df.Y1 + sim.df.subgroup  * subgroup_eff
sim.df["confounder"] = np.array([rng.choice([1.0, 0.0], p = [0.5 + confound, 0.5 - confound] ) if (group == 1) else rng.choice([0.0, 1.0], p = [0.5 + confound, 0.5 - confound]) for group in sim.df.subgroup], dtype = float)
# And affects the outcome
sim.df["Y2"] = sim.df.Y1 + sim.df.confounder * confounder_eff 


# for each columns starting with letter Y, run a simple linear regression with the 
GWASBetas = np.zeros(shape = (sim.genotypes.shape[1], sim.df.filter(regex="^Y").shape[1]))
for j in range(sim.df.filter(regex="^Y").shape[1]):
    for i in range(sim.genotypes.shape[1]):
        mod = OLS(sim.df["Y" + str(j)], sim.genotypes[:,i]).fit()
        if mod.pvalues[0] < 1e-30 :
          GWASBetas[i,j] = OLS(sim.df["Y" + str(j)] , sim.genotypes[:,i]).fit().params[0]
        else :
          GWASBetas[i,j] = 0
    sim.df[f"PRS{j}"] = np.matmul(sim.genotypes, GWASBetas[:,j])

np.save("genos2Anc.npy", sim.genotypes)

# Save GWAS results
np.save("gwas2Anc.npy", GWASBetas)

# Create confounding variable that is related to risk subgorup

# Save dataframe
sim.df.to_csv("data2Anc.csv", index = False)

# SNP_props = pd.DataFrame({"Shared" : [0, 0, 1, 1],
#               "Causal" : [0, 1, 0, 1],
#               "N" : np.array([(1 - shared) * (1 - prop_causal[0]),
#                               (1 - shared) * prop_causal[0],
#                               shared * (1 - prop_causal[1]),
#                               shared * (prop_causal[1])]) * nSNPs})
# ax = sns.barplot(data= SNP_props, x = "Shared", y = "N", hue = "Causal", )
# ax.set(yscale = "log") # plotClusters(sim)
# plt.show()
```

```{python}
plotClusters(sim)
```


```{python}
# make two subplots
# one for phenotype y0 and another for phenotype y1
p1 = sns.jointplot(x= "PRS0" , y ="Y0", data = sim.df, hue = "subgroup")
p2 = sns.jointplot(x= "PRS1" , y ="Y1", data = sim.df, hue = "subgroup")
p3 = sns.jointplot(x= "PRS1" , y ="Y2", data = sim.df, hue = "subgroup")

plt.show()
```




# Data Generating mechanism

Trying to detect risk subgroups while simultatenously compute a PRS.

$$
  Y = X_cβ_c + X_Gβ_G + X_Rβ_R + ϵ
$$

Implies

$$
  Y = X_cβ_c + PRSβ_{PRS} + PCβ_{PC} + ϵ
$$

Where $X$ is the confounding variable, $X_G$ is the genetic variable, $β$ is the effect of the confounding variable, $β_G$ is the effect of the genetic variable, $β_{PRS}$ is the effect of the PRS, $β_{PC}$ is the effect of the principal components, $X_R$ is the risk group, $β_R$ is the risk group effect, and $ϵ$ is the error term. Additionally, $X_c$ depends on $X_R$

$$
  p(X_c|X_R) = \begin{cases} 
  0.75 & \text{if } X_R = 1 \\
  0.25 & \text{if } X_R = 0
\end{cases}
$$


# PPMx fits
```{r setupR}
#| include: false
library(ppmSuite)
library(tidyverse)
library(ggfortify)
library(gt)
library(patchwork)
library(gtsummary)


ppmxsummary <- function(mod, df, ...) {
  df$predicted <- apply(mod$fitted.values, 2, mean)
  labelings <- t(mod$Si)
  df$label <- as.data.frame(sapply(1:max(mod$Si), function(x) rowMeans(labelings ==x)),
                            col.names = c("l1", "l2", "l3"))  %>%
             mutate(label = max.col(., ties.method = "first")) %>%
             pull(label) %>%
             as.factor()
  g <- df %>%
    ggplot(aes(!!!ensyms(...))) +
    geom_point() +
    geom_point(aes(y = predicted), color = "red") 
  print(g)
 
  table(df[c("label", "subgroup", "subj_ancestries")])
}

meanModel = 1
M=1e-30
similarity_function = 1
draws = 2000
burn = 500
thin = 10

# Load datafraem
df <- read_csv("data2Anc.csv")  %>%
  mutate(Y0 = (Y0 - mean(Y0))/ sd(Y0),
         Y1 = (Y1 - mean(Y1)) / sd(Y1),
         Y2 = (Y2 - mean(Y2)) / sd(Y2),
         PRS0 = (PRS0 - mean(PRS0)) / sd(PRS0),
         PRS1 = (PRS1 - mean(PRS1)) / sd(PRS1), 
         pc_1 = (pc_1 - mean(pc_1)) / sd(pc_1),
         pc1_conf = lm(pc_1 ~ confounder, data= .)$resid,
         PRS1_conf = lm(PRS1 ~ confounder, data= .)$resid,
         PRS2_conf = lm(PRS2 ~ confounder, data= .)$resid,

         Y1_conf = lm(Y1 ~ confounder, data= .)$resid,
         Y2_conf = lm(Y2 ~ confounder, data= .)$resid,
         Y2_conf_pc = lm(Y2 ~ confounder + pc_1, data= .)$resid,
         PRS1_conf_pc = lm(PRS1 ~ confounder + pc_1, data= .)$resid,
         PRS2_conf_pc = lm(PRS2 ~ confounder + pc_1, data= .)$resid,

         )
```

## Fully separable, no confounding
```{r}
# Fully separable: no confounding - 
m1 = gaussian_ppmx(y = df$Y1, X = df[c("PRS1", "pc_1")], meanModel = meanModel, M = M, similarity_function = similarity_function, draws = draws, burn = burn, thin = thin)
ppmxsummary(m1, df, x ="PRS1", y= "Y1")
```


## Fully separable, confounding obscures clusters
Residualize out confounding affect
```{r}
m2 = gaussian_ppmx(y = df$Y2_conf, X = df[c("PRS2_conf", "pc1_conf")], meanModel = meanModel, M = M, similarity_function = similarity_function, draws = draws, burn = burn, thin = thin)
ppmxsummary(m2, df, x ="PRS2_conf", y= "Y2_conf")
```
Doesn't detect subtypes

Residualize out confounding affect and PC1
```{r}
m2 = gaussian_ppmx(y = df$Y2_conf_pc, X = df[c("PRS2_conf_pc")], meanModel = meanModel, M = M, similarity_function = similarity_function, draws = draws, burn = burn, thin = thin)
ppmxsummary(m2, df, x ="PRS2_conf_pc", y= "Y2_conf_pc")
```
Regressing out all of the covariates, seems to break the cluster detection here


Fully PPMx model

```{r}
resid = gaussian_ppmx(y = df$Y2, X = df[c("PRS2", "pc_1", "confounder")], meanModel = meanModel, M = M, similarity_function = similarity_function, draws = draws, burn = burn, thin = thin)
ppmxsummary(resid, df, x ="PRS2", y= "Y2")
```
Detects confounding effects as forming clusters.


```{r}
resid = gaussian_ppmx(y = df$Y2, X = df[c("PRS2", "pc_1", "confounder", "subgroup")], meanModel = meanModel, M = M, similarity_function = similarity_function, draws = draws, burn = burn, thin = thin)
ppmxsummary(resid, df, x ="PRS2", y= "Y2")
```


